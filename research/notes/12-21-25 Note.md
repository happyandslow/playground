
# Wavel Reading Note

Based on commit: https://github.com/Chivier/wavel/commit/7b7b9650fdc10c8ec1bb96ab360592b8d4622041

## A* mapper mapping chain
### Initialization Chain

```
map()
├─ OperatorPredictor.__init__()
├─ MemoryModel.__init__()
│ └─ _build_tensor_sizes()
├─ ExpansionManager.set_graph()
├─ HeuristicCalculator.__init__()
├─ SolutionEvaluator.__init__()
├─ OperatorPartitioner.__init__()
├─ SolutionCollector.__init__()
├─ BestPathLeafCollector.__init__()
├─ CutHelper.__init__()
├─ analyze_cross_group_dependencies()
│ └─ GroupDependencyGraph.from_dependencies()
├─ DependencyAwareAllocator.__init__()
│ └─ GlobalPEAllocator.__init__()
├─ DependencyAwareAllocator.allocate_chain_groups()
├─ TuneHelper.__init__()
└─ SpatialIR.__init__()

```

  

### Mapping Chain

```
map()
└─ _map_groups_parallel() OR _map_group()
├─ _compute_dependency_levels()
└─ _map_group()
├─ _create_root_node()
│ └─ _find_optimal_initial_region()
├─ _lookup_op_group_cache()
├─ SmallGroupOptimizer.optimize()
└─ A* Search Loop
├─ _expand_node()
│ ├─ ExpansionManager.expand()
│ │ ├─ SpatialCutStrategy.apply()
│ │ ├─ TemporalCutStrategy.apply()
│ │ ├─ EdgeTuneStrategy.apply()
│ │ └─ GemmTuneStrategy.apply()
├─ _compute_heuristic()
│ └─ HeuristicCalculator.compute_heuristic()
├─ _evaluate_complete_solution()
│ └─ SolutionEvaluator.evaluate()
└─ _apply_mapping_to_spatial_ir()
└─ SolutionCollector.collect()

```

  

### Post-Processing Chain

```
map()
├─ _calculate_pe_utilization()
├─ _compress_pe_allocation()
├─ _build_timeline()
├─ shrink_idle_pes()
└─ MappingResult.__init__()
```


## Evaluation Flow
```
During A* Search:
  For each node:
    f_cost = HeuristicCalculator.compute_heuristic(node)
             ├─ g_cost: Sum of CostModel.compute_op_cost() for fixed groups
             └─ h_cost: Estimate for remaining groups
    
    MemoryModel.check_memory_feasibility(node) → Prune if infeasible

When complete solution found:
  total_cost = SolutionEvaluator.evaluate(node, graph)
               ├─ For each leaf: CostModel.compute_op_cost()
               ├─ Communication: CostModel.compute_communication_cost()
               └─ Dependency scheduling: Sequential vs parallel execution
```


## High-Level Solution Selection Process

1. A* search algorithm
-   Uses A* to explore the mapping space
-   Each SearchNode represents a partial mapping (some operators assigned to PE regions)
-   Maintains an open set (frontier) and a closed set (visited states)

2. Solution generation
-   Starts from an initial node (typically no operators mapped)
-   Expands nodes by assigning unmapped operators to PE regions
-   Generates candidate successors for each expansion step
-   Prunes invalid or dominated candidates

3. Solution evaluation

-   Two evaluation paths:
-   Subgraph evaluator (use_subgraph_eval=True): Detailed simulation using SubgraphEvaluator with SpatialPlan objects for accurate scheduling
-   Legacy cost model (use_subgraph_eval=False): Faster heuristic using CostModel.compute_op_cost() for individual operations and CostModel.compute_communication_cost() for data movement
-   Evaluation computes total execution cost (computation + communication)

4. Selection criteria

-   A* uses f(n) = g(n) + h(n):
-   g(n): Actual cost from start to current node
-   h(n): Heuristic estimate to goal (remaining operators)
-   Explores nodes with lowest f(n) first
-   Tracks the best complete solution found

5. Termination

-   Stops when:
-   A complete solution is found and no better path exists
-   Search budget (time/iterations) is exhausted
-   Open set is empty (no valid solutions)

6. Result

-   Returns the best complete mapping found (all operators assigned to PE regions with minimal total cost)

The process balances exploration (trying different mappings) with exploitation (focusing on promising paths) to find an efficient spatial mapping.




<!--stackedit_data:
eyJoaXN0b3J5IjpbMjA3NTg1NTY2MSwxNzM3MzgyODUsMTcxNz
E3MTYzLDgxODYzNjEyOSwtMjAxNTU2Njg2MiwxNDg4MDY0MTg0
LC0yMDA3MTQ1NzEzLC03OTU0MzcyODNdfQ==
-->